<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*global _ */
/* exported Template */
var Template = (function() {
	var legacyPreprocess = function(text) {
		// first, support legacy template format of {data}
		return text.replace(/\{{1,}/g, &quot;{{&quot;).replace(/\}{1,}/g, &quot;}}&quot;)
			// we need to both support {uri} and {uri.id}, there is an obvious conflict there.
			.replace(/\{uri\./, &quot;{uriParts.&quot;)
			// last, scope the data, this lets us have undefined vars.
			.replace(/\{{2,}/g, &quot;{{data.&quot;);
	};
	return {
		INTERPOLATE: /\{\{(.+?)\}\}/g,
<span id='global-method-process'>		/**
</span>		 * @ignore
		 * text can be a single string, an object with string properites, or an array of strings.
		 */
		process: function(text, data, keys) {
			// parse strings like {uri}
			if (_.isString(text)) {
				return _.template(legacyPreprocess(text), {
					interpolate: Template.INTERPOLATE
				})({
					data: data
				});
			} else {
				_(text).each(function(prop, key) {
					if (!keys || _.contains(keys, key)) {
						// do an extra check to make sure there is a template, perhaps enhancing performance.
						if (_.isString(prop) &amp;&amp; prop.indexOf(&quot;{&quot;) !== -1) {
							text[key] = _.template(legacyPreprocess(prop), {
								interpolate: Template.INTERPOLATE
							})({
								data: data
							});
						}
					}
				});
				return text;
			}
		},
<span id='global-method-buildTemplateData'>		/**
</span>		 * @ignore
		 * This is equivalent to the TemplateProxy in flash.
		 */
		buildTemplateData: function(player, currentMetadata, extraData) {
			var data = _.extend({}, player.config, extraData),
				splitUri = data.uri.split(&quot;:&quot;);
			// build uri
			data.uriParts = {
				namespace: splitUri[3],
				id: splitUri[4]
			};
			data.currentMetadata = currentMetadata;
			// metadata for legacy
			data.metadata = player.currentMetadata ? player.currentMetadata.rss : null;
			data.playlistMetadata = player.playlistMetadata;
			// future tempales can just access properties on the embed api.
			data.player = player;
			// legacy this is in flash player, not sure if used.
			data.app = {
				width: data.width,
				height: data.height
			};
			return data;
		}
	};
})();
</pre>
</body>
</html>
