<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* global Player, Core, Config, Events, _, ModuleManager */
// TODO isHTML5Player was useful for knowing if you can invoke play() without
// waiting for a poster screen click.
_.extend(Player.prototype, (function() {
<span id='global-method-getPlayerInstance'>	/**
</span>	 * @method getPlayerInstance
	 * @ignore
	 * @param {ContentWindow} source
	 * @returns {PJS.Player} A player instance
	 */
	var getPlayerInstance = function(source) {
			var i, player = null,
				numberOfInstances = Core.instances.length,
				currentInstance;
			for (i = numberOfInstances; i--;) {
				currentInstance = Core.instances[i];
				if (currentInstance.player.config.isSyndicatedLegacyHTML5) {
					// these exist only in iframes.
					return currentInstance.player;
				}
				if (currentInstance.player.element.contentWindow === source) {
					// compare source (contentWindow) to get events object from the right player. (if flash, source is the embed id)
					player = currentInstance.player;
					break;
				}
			}
			return player;
		},
<span id='global-method-'>		/**
</span>		 * remove an instance from the hash map.
		 * @ignore
		 * @param {contentWindow} source
		 */
		removePlayerInstance = function(source) {
			Core.instances = _.reject(Core.instances, function(instance) {
				return instance.player.element.contentWindow === source;
			});
		},
<span id='global-method-exitFullScreen'>		/**
</span>		 * return the iframe to it&#39;s original width and height.
		 * @method exitFullScreen
		 * @ignore
		 * @param {PJS.Player} player
		 */
		exitFullScreen = function(player) {
			player.isFullScreen = false;
			var c = player.config;
			player.$el.css({
				position: &quot;static&quot;,
				zIndex: &quot;auto&quot;,
				width: c.width + &quot;px&quot;,
				height: c.height + &quot;px&quot;
			});
			player.element.width = c.width + &quot;px&quot;;
			player.element.height = c.height + &quot;px&quot;;
			player.trigger(Events.FULL_SCREEN_CHANGE);
		},
<span id='global-method-goFullScreen'>		/**
</span>		 * @method goFullScreen
		 * @ignore
		 * @param {IFrameElement} iframeElement
		 */
		goFullScreen = function(player) {
			player.isFullScreen = true;
			player.$el.css({
				position: &quot;fixed&quot;,
				left: 0,
				top: 0,
				zIndex: player.config.highestZIndex || 2147483645,
				width: window.innerWidth,
				height: window.innerHeight
			});
			player.element.width = window.innerWidth + &quot;px&quot;;
			player.element.height = window.innerHeight + &quot;px&quot;;
			if (Config.needsScrollToForFullScreen(navigator.userAgent)) {
				window.scrollTo(0, 0);
			}
			player.trigger(Events.FULL_SCREEN_CHANGE);
		},
<span id='global-property-'>		/**
</span>		 * @ignore
		 * Overwritten by the syndicated iframe stuff, see `create`.
		 */
		postMessage = function(player, message) {
			return player.element.contentWindow.postMessage(message, &quot;*&quot;);
		},
		triggerReady = function(player) {
			player.ready = true;
			var fv = player.config.flashVars;
			if (fv &amp;&amp; fv.sid) {
				player.message(&quot;setSSID:&quot; + fv.sid);
			}
			var startIndex = parseInt(player.config.startIndex, 10);
			if (!isNaN(startIndex) &amp;&amp; startIndex &gt; 0) {
				player.message(&quot;startIndex:&quot; + startIndex);
			}
			if (player.config.test) {
				player.message(&quot;overwriteConfig:&quot; + JSON.stringify(player.config.test));
			}
			// pass in tve params.
			if (player.config.tve) {
				player.message(&quot;overwriteConfig:&quot; + JSON.stringify(player.config.tve));
			}
			Core.executeCallbacks(player);
			player.trigger(Events.READY);
		},
<span id='global-method-getMessageData'>		/**
</span>		 * @method getMessageData
		 * @ignore
		 */
		getMessageData = function(data) {
			if (!_.isString(data)) {
				return;
			}
			return data.slice(data.indexOf(&quot;:&quot;) + 1);
		},
<span id='global-method-onMetadata'>		/**
</span>		 * @method onMetadata
		 * @ignore
		 * @param {Object} data Event data
		 * @param {PJS.Player} player A player instance
		 */
		onMetadata = function(obj, player) {
			var newIndex = obj.index,
				oldIndex = player.playlistMetadata.index;
			player.currentMetadata = obj;
			if (newIndex !== -1) { // index is -1 for ads.
				player.playlistMetadata.items[obj.index] = obj;
				player.playlistMetadata.index = obj.index;
				if (newIndex !== oldIndex) {
					player.trigger(Events.INDEX_CHANGE, newIndex);
				}
			}
			player.trigger(Events.METADATA, obj);
		},
<span id='global-method-handleMessage'>		/**
</span>		 * @method handleMessage
		 * @ignore
		 */
		handleMessage = function(event) {
			var data = event.data,
				playhead, events, eventTypes = Events;
			if (data &amp;&amp; data.indexOf &amp;&amp; data.indexOf(&quot;logMessage:&quot;) === -1) {
				var player = getPlayerInstance(event.source),
					messageData = getMessageData(data);
				if (player) {
					events = player.events;
					if (data.indexOf(&quot;playState:&quot;) === 0) {
						player.state = messageData;
						player.trigger(eventTypes.STATE_CHANGE, player.state);
						player.trigger(eventTypes.STATE_CHANGE + &quot;:&quot; + player.state, player.state);
					} else if (data.indexOf(&quot;config:&quot;) === 0) {
						Config.copyProperties(player.config, JSON.parse(messageData));
					} else if (data.indexOf(&quot;performance:&quot;) === 0 &amp;&amp; player.config.performance) {
						Core.processPerformance(player, JSON.parse(messageData));
					} else if (data.indexOf(&quot;playlistComplete&quot;) === 0) {
						player.trigger(eventTypes.PLAYLIST_COMPLETE);
					} else if (data.indexOf(&quot;durationChange:&quot;) === 0) {
						if (player.currentMetadata) {
							player.currentMetadata.duration = parseFloat(messageData, 10);
							player.trigger(eventTypes.DURATION_CHANGE, player.currentMetadata.duration);
						}
					} else if (data.indexOf(&quot;metadata:&quot;) === 0) {
						onMetadata(JSON.parse(messageData), player);
					} else if (data.indexOf(&quot;mediaStart&quot;) === 0) {
						player.trigger(eventTypes.MEDIA_START);
					} else if (data.indexOf(&quot;mediaEnd&quot;) === 0) {
						player.trigger(eventTypes.MEDIA_END);
					} else if (data.indexOf(&quot;playheadUpdate&quot;) === 0) {
						var lastPlayhead = Math.floor(player.playhead);
						playhead = parseInt(messageData, 10);
						player.playhead = playhead;
						player.trigger(eventTypes.PLAYHEAD_UPDATE, playhead);
						// support for cue points.
						if (lastPlayhead !== Math.floor(playhead)) {
							player.trigger(eventTypes.PLAYHEAD_UPDATE + &quot;:&quot; + Math.floor(playhead), playhead);
						}
					} else if (data.indexOf(&quot;playlistMetadata:&quot;) === 0) {
						player.playlistMetadata = JSON.parse(messageData);
					} else if (data === &quot;onReady&quot;) {
						triggerReady(player);
					} else if (data === &quot;fullscreen&quot;) {
						if (player.isFullScreen) {
							exitFullScreen(player);
						} else {
							goFullScreen(player);
						}
					} else if (data.indexOf(&quot;overlayRectChange:&quot;) === 0) {
						player.trigger(eventTypes.OVERLAY_RECT_CHANGE, JSON.parse(messageData));
					} else if (data.indexOf(&quot;onUIStateChange:&quot;) === 0) {
						player.trigger(eventTypes.UI_STATE_CHANGE, JSON.parse(messageData));
					} else if (data.indexOf(&quot;airplay&quot;) === 0) {
						player.trigger(eventTypes.AIRPLAY);
					} else if (data.indexOf(&quot;showCCPrefs:&quot;) === 0) {
						if (player.config.isSyndicatedLegacyHTML5) {
							// only respond to this event when in a legacy iframe.
							player.module(&quot;cc-prefs&quot;).show(JSON.parse(messageData));
						}
					} else if (data.indexOf(&quot;showCCPanel:&quot;) === 0) {
						if (player.config.isSyndicatedLegacyHTML5) {
							// only respond to this event when in a legacy iframe.
							player.module(&quot;cc-panel&quot;).show(messageData === &quot;true&quot;);
						}
					}
				}
			}
		},
		createElement = function(player) {
			var config = player.config,
				element = document.createElement(&quot;iframe&quot;);
			element.setAttribute(&quot;id&quot;, player.id);
			element.setAttribute(&quot;src&quot;, Core.getPath(config));
			element.setAttribute(&quot;frameborder&quot;, &quot;0&quot;);
			element.setAttribute(&quot;scrolling&quot;, &quot;no&quot;);
			element.setAttribute(&quot;type&quot;, &quot;text/html&quot;);
			element.width = element.height = &quot;100%&quot;;
			// no placeholders on html5, so clear it out.
			player.$el.empty();
			player.$el.append(element);
			player.element = element;
		},
		callFullScreenOnAll = function() {
			var i, player = null,
				instances = Core.instances,
				numberOfInstances = instances.length;
			for (i = numberOfInstances; i--;) {
				player = instances[i].player;
				if (player.isFullScreen) {
					goFullScreen(player);
				}
			}
		};
	window.addEventListener(&quot;orientationchange&quot;, function() {
		// set up orientationchange handler
		callFullScreenOnAll();
		// some browsers don&#39;t have a refreshed innerWidth and innerHeight immediately, invoke again after 500ms.
		setTimeout(callFullScreenOnAll, 500);
	}, false);
	return {
		canUsePlaceholder: false,
<span id='global-method-create'>		/**
</span>		 * create the player iframe
		 * @method create
		 * @ignore
		 */
		create: function() {
			if (!this.module) {
				this.module = new ModuleManager({
					player: this
				});
			}
			if (!this.config.isSyndicatedLegacyHTML5) {
				// standard initialization
				createElement(this);
				Core.instances.push({
					player: this
				});
			} else {
				// syndicated initialization
				this.element = window;
				Core.instances.push({
					player: this
				});
				// just post off the window here.
				postMessage = function(player, message) {
					return window.postMessage(message, &quot;*&quot;);
				};
				triggerReady(this);
			}
			if (typeof window.addEventListener !== &#39;undefined&#39;) {
				window.addEventListener(&#39;message&#39;, handleMessage, false);
			} else if (typeof window.attachEvent !== &#39;undefined&#39;) {
				window.attachEvent(&#39;onmessage&#39;, handleMessage);
			}
		},
<span id='global-method-message'>		/**
</span>		 * Send messages to the iframe via post message.
		 * Run in the context of {@link PJS.Player}
		 * @method message
		 * @ignore
		 */
		message: function(message) {
			if (!this.ready) {
				throw new Error(&quot;PJS.Player.&quot; + message + &quot;() called before player loaded.&quot;);
			}
			if (message === &quot;showCCPanel&quot;) {
				// I have events and methods both invoking postMessage in the html5 player iframe.
				message = &quot;legacyShowCCPanel&quot;;
			}
			if (message === &quot;showCCPrefs&quot;) {
				message = &quot;legacyShowCCPrefs&quot;;
			}
			switch (message) {
				case &quot;volume&quot;:
					if (_.isUndefined(arguments[1])) {
						// TODO implement 
						return NaN;
					} else {
						// html5 player expects setVolume.
						this.element.contentWindow.postMessage(&quot;setVolume&quot; + arguments[1], &quot;*&quot;);
					}
					break;
				case &quot;goFullScreen&quot;:
					goFullScreen.apply(this, [this]);
					break;
				case &quot;exitFullScreen&quot;:
					exitFullScreen.apply(this, [this]);
					break;
				case &quot;playUri&quot;:
				case &quot;playURI&quot;:
					this.config.uri = arguments[1];
					// when calling play uri from the player we lose the ref, call it from the page instead.
					this.element.src = Core.getPath(this.config);
					break;
				default:
					if (arguments[1] !== undefined) {
						message += &quot;:&quot; + arguments[1] + (arguments[2] !== undefined ? &quot;,&quot; + arguments[2] : &quot;&quot;);
					}
					return postMessage(this, message);
			}
		},
		destroy: function() {
			if (this.element) {
				removePlayerInstance(this.element.contentWindow);
			}
			if (this.$el) {
				this.$el.remove();
			}
			delete this.$el;
			delete this.element;
			delete this.playerTarget;
		}
	};
})());
</pre>
</body>
</html>
